<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gradient 3D — ∇f(x,y) = x² + y²</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    background: #0a0a0a;
    color: #e0e0e0;
}

canvas { display: block; cursor: crosshair; }

.bottom {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 16px 0 22px;
    background: #0a0a0a;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    z-index: 10;
}

.values {
    display: flex;
    gap: 50px;
    font-size: 1.05rem;
}
.values .item { text-align: center; }
.values .label {
    color: #666;
    font-size: 0.75rem;
    margin-bottom: 4px;
}
.values .num {
    font-size: 1.3rem;
    font-weight: 600;
}
.values .num.xy-val { color: #e0e0e0; }
.values .num.fxy-val { color: #5e9cff; }
.values .num.grad-val { color: #f0c040; }

.hint {
    font-size: 0.65rem;
    color: #444;
}
</style>
</head>
<body>

<canvas id="cv"></canvas>

<div class="bottom">
    <div class="values">
        <div class="item">
            <div class="label">x, y</div>
            <div class="num xy-val" id="v-xy">1.00, 1.00</div>
        </div>
        <div class="item">
            <div class="label">f(x,y) = x² + y²</div>
            <div class="num fxy-val" id="v-fxy">2.00</div>
        </div>
        <div class="item">
            <div class="label">∇f = [∂f/∂x, ∂f/∂y]</div>
            <div class="num grad-val" id="v-grad">[2.00, 2.00]</div>
        </div>
    </div>
    <div class="hint">drag to move point · shift+drag to rotate</div>
</div>

<script>
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
const bottomH = 90;

// 3D view angles
let az = 2.3, el = 0.55;

// Point position on x/y plane
let px = 1.0, py = 1.0;

// Drag state
let dragging = false, rotating = false;
let lastMX = 0, lastMY = 0;

// Surface config
const RANGE = 3.6;
const GRID = 40;

function f(x, y) { return x * x + y * y; }

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight - bottomH;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const W = canvas.width / (window.devicePixelRatio || 1);
    const H = canvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0, 0, W, H);

    const cosA = Math.cos(az), sinA = Math.sin(az);
    const cosE = Math.cos(el), sinE = Math.sin(el);
    const scale = Math.min(W, H) * 0.11;
    // Shift center down so the paraboloid fills upward
    const cx = W / 2, cy = H * 0.65;

    function proj(x, y, z) {
        const rx = x * cosA - y * sinA;
        const ry = x * sinA + y * cosA;
        const ry2 = ry * cosE + z * sinE;
        const rz = -ry * sinE + z * cosE;
        return [cx + rx * scale, cy - ry2 * scale, rz];
    }

    // Build quads for the surface and the base grid
    const quads = [];
    const step = (2 * RANGE) / GRID;

    // Surface quads
    for (let j = 0; j < GRID; j++) {
        for (let i = 0; i < GRID; i++) {
            const x0 = -RANGE + i * step, x1 = x0 + step;
            const y0 = -RANGE + j * step, y1 = y0 + step;
            const z00 = f(x0, y0), z10 = f(x1, y0);
            const z01 = f(x0, y1), z11 = f(x1, y1);
            const c = [proj(x0, y0, z00), proj(x1, y0, z10),
                       proj(x1, y1, z11), proj(x0, y1, z01)];
            const avgZ = (c[0][2] + c[1][2] + c[2][2] + c[3][2]) / 4;
            const avgH = (z00 + z10 + z01 + z11) / 4;
            quads.push({ c, avgZ, avgH, type: 's' });
        }
    }

    // Base plane grid (z=0)
    const BASE_GRID = 6;
    const bstep = (2 * RANGE) / BASE_GRID;
    for (let j = 0; j < BASE_GRID; j++) {
        for (let i = 0; i < BASE_GRID; i++) {
            const x0 = -RANGE + i * bstep, x1 = x0 + bstep;
            const y0 = -RANGE + j * bstep, y1 = y0 + bstep;
            const c = [proj(x0, y0, 0), proj(x1, y0, 0),
                       proj(x1, y1, 0), proj(x0, y1, 0)];
            const avgZ = (c[0][2] + c[1][2] + c[2][2] + c[3][2]) / 4;
            quads.push({ c, avgZ, type: 'g' });
        }
    }

    // Vertical dashed line quad (as line objects to interleave in depth sort)
    const fVal = f(px, py);
    const pBase = proj(px, py, 0);
    const pSurf = proj(px, py, fVal);
    const pMidZ = (pBase[2] + pSurf[2]) / 2;

    // Gradient arrow endpoints
    const gx = 2 * px, gy = 2 * py;
    const gradMag = Math.sqrt(gx * gx + gy * gy);
    // Cap arrow length for visual clarity
    const arrowScale = Math.min(1.0, 3.0 / (gradMag + 0.01));
    const ax = px + gx * arrowScale, ay = py + gy * arrowScale;
    const pArrowEnd = proj(ax, ay, 0);
    const arrowMidZ = (pBase[2] + pArrowEnd[2]) / 2;

    // Add point/arrow/line as special quads for depth sorting
    quads.push({ type: 'line', avgZ: pMidZ });
    quads.push({ type: 'arrow', avgZ: arrowMidZ });
    quads.push({ type: 'pointBase', avgZ: pBase[2] + 0.01 });
    quads.push({ type: 'pointSurf', avgZ: pSurf[2] + 0.01 });

    // Painter's algorithm: sort back to front
    quads.sort((a, b) => a.avgZ - b.avgZ);

    const maxZ = RANGE * RANGE * 2; // max height for color mapping

    for (const q of quads) {
        if (q.type === 'g') {
            // Base grid
            ctx.beginPath();
            ctx.moveTo(q.c[0][0], q.c[0][1]);
            for (let k = 1; k < 4; k++) ctx.lineTo(q.c[k][0], q.c[k][1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        } else if (q.type === 's') {
            // Surface quad
            const t = Math.min(q.avgH / maxZ, 1);
            const r = Math.round(30 + t * 50);
            const g = Math.round(120 + t * 40);
            const b = Math.round(200 + t * 55);
            const alpha = 0.55 + t * 0.35;
            ctx.beginPath();
            ctx.moveTo(q.c[0][0], q.c[0][1]);
            for (let k = 1; k < 4; k++) ctx.lineTo(q.c[k][0], q.c[k][1]);
            ctx.closePath();
            ctx.fillStyle = `rgba(${r},${g},${b},${alpha.toFixed(2)})`;
            ctx.fill();
            ctx.strokeStyle = `rgba(0,0,0,0.15)`;
            ctx.lineWidth = 0.3;
            ctx.stroke();
        } else if (q.type === 'line') {
            // Vertical dashed line from base to surface
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pBase[0], pBase[1]);
            ctx.lineTo(pSurf[0], pSurf[1]);
            ctx.stroke();
            ctx.setLineDash([]);
        } else if (q.type === 'arrow') {
            // Gradient arrow on z=0 plane
            if (gradMag > 0.05) {
                ctx.strokeStyle = '#f0c040';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(pBase[0], pBase[1]);
                ctx.lineTo(pArrowEnd[0], pArrowEnd[1]);
                ctx.stroke();

                // Arrowhead
                const dx = pArrowEnd[0] - pBase[0];
                const dy = pArrowEnd[1] - pBase[1];
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len > 1) {
                    const ux = dx / len, uy = dy / len;
                    const headLen = 10;
                    const headW = 5;
                    ctx.fillStyle = '#f0c040';
                    ctx.beginPath();
                    ctx.moveTo(pArrowEnd[0], pArrowEnd[1]);
                    ctx.lineTo(pArrowEnd[0] - ux * headLen + uy * headW,
                               pArrowEnd[1] - uy * headLen - ux * headW);
                    ctx.lineTo(pArrowEnd[0] - ux * headLen - uy * headW,
                               pArrowEnd[1] - uy * headLen + ux * headW);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        } else if (q.type === 'pointBase') {
            // Point on z=0 plane
            ctx.beginPath();
            ctx.arc(pBase[0], pBase[1], 5, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pBase[0], pBase[1], 3, 0, Math.PI * 2);
            ctx.fillStyle = '#5e9cff';
            ctx.fill();
        } else if (q.type === 'pointSurf') {
            // Point on surface
            ctx.beginPath();
            ctx.arc(pSurf[0], pSurf[1], 6, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(pSurf[0], pSurf[1], 4, 0, Math.PI * 2);
            ctx.fillStyle = '#5e9cff';
            ctx.fill();
        }
    }

    // Axes
    const o = proj(-RANGE, -RANGE, 0);
    const axEnd = proj(RANGE + 0.5, -RANGE, 0);
    const ayEnd = proj(-RANGE, RANGE + 0.5, 0);
    const azEnd = proj(-RANGE, -RANGE, maxZ * 0.7);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(o[0], o[1]); ctx.lineTo(axEnd[0], axEnd[1]); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(o[0], o[1]); ctx.lineTo(ayEnd[0], ayEnd[1]); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(o[0], o[1]); ctx.lineTo(azEnd[0], azEnd[1]); ctx.stroke();
    ctx.fillStyle = '#666';
    ctx.font = '12px SF Mono, Consolas, monospace';
    ctx.fillText('x', axEnd[0] + 6, axEnd[1] + 2);
    ctx.fillText('y', ayEnd[0] + 6, ayEnd[1] + 2);
    ctx.fillText('f', azEnd[0] + 6, azEnd[1] - 2);

    // Update value panel
    document.getElementById('v-xy').textContent =
        px.toFixed(2) + ', ' + py.toFixed(2);
    document.getElementById('v-fxy').textContent = fVal.toFixed(2);
    document.getElementById('v-grad').textContent =
        '[' + (2 * px).toFixed(2) + ', ' + (2 * py).toFixed(2) + ']';
}

// --- Inverse projection: screen click → x/y on z=0 plane ---
function screenToXY(sx, sy) {
    const W = canvas.width / (window.devicePixelRatio || 1);
    const H = canvas.height / (window.devicePixelRatio || 1);
    const scale = Math.min(W, H) * 0.11;
    const cx = W / 2, cy = H * 0.65;
    const cosA = Math.cos(az), sinA = Math.sin(az);
    const cosE = Math.cos(el), sinE = Math.sin(el);

    // Screen coords relative to center (matching proj formula)
    const rx = (sx - cx) / scale;
    const ry2 = -(sy - cy) / scale;

    // For z=0: proj gives ry2 = ry * cosE, so ry = ry2 / cosE
    const ry = ry2 / cosE;
    // Inverse azimuth rotation: x = rx*cosA + ry*sinA, y = -rx*sinA + ry*cosA
    const x = rx * cosA + ry * sinA;
    const y = -rx * sinA + ry * cosA;
    return [x, y];
}

// --- Mouse interaction ---
canvas.addEventListener('mousedown', (e) => {
    lastMX = e.clientX;
    lastMY = e.clientY;
    if (e.shiftKey || e.button === 2) {
        rotating = true;
        canvas.style.cursor = 'grabbing';
    } else {
        dragging = true;
        // Move point to click position
        const rect = canvas.getBoundingClientRect();
        const [x, y] = screenToXY(e.clientX - rect.left, e.clientY - rect.top);
        px = Math.max(-RANGE, Math.min(RANGE, x));
        py = Math.max(-RANGE, Math.min(RANGE, y));
        draw();
    }
});

window.addEventListener('mousemove', (e) => {
    if (rotating) {
        az += (e.clientX - lastMX) * 0.008;
        el = Math.max(0.15, Math.min(1.4, el - (e.clientY - lastMY) * 0.008));
        lastMX = e.clientX;
        lastMY = e.clientY;
        draw();
    } else if (dragging) {
        const rect = canvas.getBoundingClientRect();
        const [x, y] = screenToXY(e.clientX - rect.left, e.clientY - rect.top);
        px = Math.max(-RANGE, Math.min(RANGE, x));
        py = Math.max(-RANGE, Math.min(RANGE, y));
        draw();
    }
});

window.addEventListener('mouseup', () => {
    dragging = false;
    rotating = false;
    canvas.style.cursor = 'crosshair';
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    lastMX = t.clientX;
    lastMY = t.clientY;
    if (e.touches.length === 2) {
        rotating = true;
    } else {
        dragging = true;
        const rect = canvas.getBoundingClientRect();
        const [x, y] = screenToXY(t.clientX - rect.left, t.clientY - rect.top);
        px = Math.max(-RANGE, Math.min(RANGE, x));
        py = Math.max(-RANGE, Math.min(RANGE, y));
        draw();
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    if (rotating || e.touches.length === 2) {
        az += (t.clientX - lastMX) * 0.008;
        el = Math.max(0.15, Math.min(1.4, el - (t.clientY - lastMY) * 0.008));
        rotating = true;
    } else if (dragging) {
        const rect = canvas.getBoundingClientRect();
        const [x, y] = screenToXY(t.clientX - rect.left, t.clientY - rect.top);
        px = Math.max(-RANGE, Math.min(RANGE, x));
        py = Math.max(-RANGE, Math.min(RANGE, y));
    }
    lastMX = t.clientX;
    lastMY = t.clientY;
    draw();
}, { passive: false });

canvas.addEventListener('touchend', () => {
    dragging = false;
    rotating = false;
});

function onResize() {
    resize();
    draw();
}
window.addEventListener('resize', onResize);
onResize();
</script>

</body>
</html>
