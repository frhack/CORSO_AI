<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dx &mdash; Maze BFS/DFS</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #f5f5f5; color: #24292e;
    height: 100vh; overflow: hidden;
}

/* --- Two-panel layout --- */
main {
    display: grid;
    grid-template-columns: 420px 1fr;
    height: 100vh;
}
@media (max-width: 900px) {
    main { grid-template-columns: 1fr; }
    .code-panel { max-height: 35vh; }
}

/* --- Left: code editor --- */
.code-panel {
    border-right: 1px solid #d0d7de;
    display: flex;
    flex-direction: column;
    background: #ffffff;
    overflow: hidden;
}
.panel-header {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 11px; color: #656d76; text-transform: uppercase;
    letter-spacing: 1px; padding: 10px 16px 8px;
    border-bottom: 1px solid #d0d7de; background: #f6f8fa;
    flex-shrink: 0;
    display: flex; align-items: center; gap: 12px;
}
.panel-header .filename { color: #656d76; }
.panel-header .lang { color: #0550ae; font-size: 9px; background: rgba(5,80,174,0.08); padding: 2px 6px; border-radius: 3px; }

.editor-wrap {
    position: relative;
    flex: 1;
    overflow: hidden;
}
.editor-wrap pre, .editor-wrap textarea {
    font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'Menlo', 'Consolas', monospace;
    font-size: 12.5px; line-height: 1.55; padding: 12px 16px;
    tab-size: 4; margin: 0; border: none; outline: none;
    white-space: pre; overflow: auto;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
}
.editor-highlight {
    background: #ffffff; color: #24292e; pointer-events: none; z-index: 0;
}
.editor-textarea {
    background: transparent; color: transparent; caret-color: #24292e;
    z-index: 1; resize: none; -webkit-text-fill-color: transparent;
}

/* Syntax classes */
.kw { color: #cf222e; }
.ty { color: #0550ae; }
.fn { color: #8250df; }
.num { color: #0550ae; }
.str { color: #0a3069; }
.cm { color: #6e7781; font-style: italic; }
.pr { color: #953800; font-weight: 600; }
.op { color: #cf222e; }

/* --- Right: maze viz --- */
.viz-panel {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background: #f5f5f5;
}

.top-bar {
    padding: 10px 20px;
    background: #f6f8fa;
    display: flex;
    align-items: center;
    gap: 18px;
    border-bottom: 1px solid #d0d7de;
    flex-shrink: 0;
    flex-wrap: wrap;
}
.top-bar .title {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.82rem;
    color: #656d76;
    letter-spacing: 0.5px;
}
.top-bar .stats {
    display: flex;
    gap: 20px;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.75rem;
}
.top-bar .stat-label { color: #8b949e; margin-right: 5px; }
.top-bar .stat-val { font-weight: 600; }
.stat-val.path-len { color: #cf222e; }
.stat-val.explored { color: #2da44e; }
.stat-val.grid-size { color: #0550ae; }

.controls {
    margin-left: auto;
    display: flex;
    gap: 10px;
    align-items: center;
}

button {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    background: #f6f8fa;
    color: #24292e;
    border: 1px solid #d0d7de;
    padding: 5px 14px;
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: pointer;
    transition: all 0.15s;
}
button:hover { background: #eaeef2; border-color: #bbb; }
button.active { background: #dafbe1; border-color: #2da44e; color: #1a7f37; }

.slider-group {
    display: flex;
    align-items: center;
    gap: 6px;
}
.slider-group label {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    color: #8b949e;
    font-size: 0.72rem;
}
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 80px;
    height: 3px;
    background: #d0d7de;
    border-radius: 2px;
    outline: none;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px; height: 12px;
    background: #0550ae;
    border-radius: 50%;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 12px; height: 12px;
    background: #0550ae;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.canvas-wrap {
    flex: 1;
    position: relative;
    overflow: hidden;
}
.canvas-wrap canvas {
    position: absolute;
    top: 0; left: 0;
}

/* --- Console output --- */
.console-bar {
    border-top: 1px solid #d0d7de;
    background: #f6f8fa;
    padding: 8px 16px;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 11px;
    color: #1a7f37;
    max-height: 90px;
    overflow-y: auto;
    white-space: pre;
    flex-shrink: 0;
}
.console-bar .err { color: #cf222e; }
.console-bar .meta { color: #8b949e; font-style: italic; }
</style>
</head>
<body>

<main>
    <!-- Left panel: code editor -->
    <section class="code-panel">
        <div class="panel-header">
            <span class="filename">maze.dx</span>
            <span class="lang">dx &rarr; JS</span>
        </div>
        <div class="editor-wrap">
            <pre class="editor-highlight" id="editor-highlight"></pre>
            <textarea class="editor-textarea" id="source-editor" spellcheck="false"></textarea>
        </div>
    </section>

    <!-- Right panel: maze viz -->
    <section class="viz-panel">
        <div class="top-bar">
            <span class="title">maze &middot; <span id="s-algo">bfs</span></span>
            <div class="stats">
                <span><span class="stat-label">grid</span><span class="stat-val grid-size" id="s-grid">20x20</span></span>
                <span><span class="stat-label">path</span><span class="stat-val path-len" id="s-path">-</span></span>
                <span><span class="stat-label">explored</span><span class="stat-val explored" id="s-explored">-</span></span>
            </div>
            <div class="controls">
                <div class="slider-group">
                    <label>size</label>
                    <input type="range" id="sizeSlider" min="5" max="40" step="1" value="20">
                </div>
                <div class="slider-group">
                    <label>speed</label>
                    <input type="range" id="speedSlider" min="1" max="100" step="1" value="50">
                </div>
                <button id="btnBfs" class="active">BFS</button>
                <button id="btnDfs">DFS</button>
                <button id="btnNew">new maze</button>
                <button id="btnSolve">solve</button>
                <button id="btnStep">step</button>
            </div>
        </div>

        <div class="canvas-wrap">
            <canvas id="maze"></canvas>
        </div>

        <div class="console-bar" id="console-out"></div>
    </section>
</main>

<script src="dx_compiler.js"></script>
<script>
// ===== Default dx source =====
const DX_SOURCE = `-- Maze solver: BFS or DFS
-- Compiled from dx to JS in your browser!
--
-- _W, _H       : maze dimensions (injected)
-- _USE_BFS     : true for BFS, false for DFS
-- _has_edge(x1, y1, x2, y2) : edge check

type Pt
    x: Int
    y: Int

fun neighbors(p)
    return [
        Pt(p'x + 1, p'y), Pt(p'x - 1, p'y),
        Pt(p'x, p'y + 1), Pt(p'x, p'y - 1)]

fun valid(p)
    return p'x >= 0 and p'x < _W and p'y >= 0 and p'y < _H

fun cerca(frontier)
    start : Pt(0, 0)
    exits : [
        Pt(_W - 1, _H - 1),
        Pt(_W - 1, 0),
        Pt(0, _H - 1)]
    frontier'put(start)
    paths : {}
    paths[start] : [start]
    explored : []
    while not frontier'empty()
        cur : frontier'get()
        explored'push([cur'x, cur'y])
        if exits'contains(cur)
            path : paths[cur]'map((p) => [p'x, p'y])
            return {explored = explored, path = path, gx = cur'x, gy = cur'y}
        for n in neighbors(cur)
            if valid(n) and not (n in paths)
                if _has_edge(cur'x, cur'y, n'x, n'y)
                    frontier'put(n)
                    paths[n] : paths[cur] + [n]
    return {explored = explored, path = [], gx = -1, gy = -1}

frontier : Stack[]
if _USE_BFS
    frontier : Queue[]
result : cerca(frontier)`;

// ===== Syntax highlighting =====
function highlightDx(code) {
    let h = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return h.split('\n').map(line => {
        const cmIdx = line.indexOf('--');
        let cp = cmIdx >= 0 ? line.slice(0, cmIdx) : line;
        let cm = cmIdx >= 0 ? '<span class="cm">' + line.slice(cmIdx) + '</span>' : '';
        cp = cp.replace(/(\"(?:[^\"\\]|\\.)*?\")/g, '<span class="str">$1</span>');
        cp = cp.replace(/\b(type|fun|for|if|else|in|while|return|true|false|and|or|not|is|has|pre|post|on)\b/g, '<span class="kw">$1</span>');
        cp = cp.replace(/\b(Stack|Queue|Pt|Edge|Int|Float|Str|Bool)\b/g, '<span class="ty">$1</span>');
        cp = cp.replace(/\bd\b/g, '<span class="op">d</span>');
        cp = cp.replace(/\b(print)\b/g, '<span class="fn">$1</span>');
        cp = cp.replace(/\b(it|me)\b/g, '<span class="pr">$1</span>');
        cp = cp.replace(/\b(\d+\.?\d*)\b/g, '<span class="num">$1</span>');
        return cp + cm;
    }).join('\n');
}

const editor = document.getElementById('source-editor');
const pre = document.getElementById('editor-highlight');
const consoleOut = document.getElementById('console-out');

function syncHighlight() { pre.innerHTML = highlightDx(editor.value) + '\n'; }
function syncScroll() { pre.scrollTop = editor.scrollTop; pre.scrollLeft = editor.scrollLeft; }
editor.addEventListener('input', syncHighlight);
editor.addEventListener('scroll', syncScroll);
editor.value = DX_SOURCE;
syncHighlight();

// Tab key
editor.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
        e.preventDefault();
        const s = editor.selectionStart, end = editor.selectionEnd;
        editor.value = editor.value.substring(0, s) + '    ' + editor.value.substring(end);
        editor.selectionStart = editor.selectionEnd = s + 4;
        syncHighlight();
    }
});

// ===== Maze generation =====
function edgeKey(a, b) {
    const [x1,y1] = a, [x2,y2] = b;
    if (x1 < x2 || (x1 === x2 && y1 < y2)) return `${x1},${y1}|${x2},${y2}`;
    return `${x2},${y2}|${x1},${y1}`;
}

function neighbors4(x, y) {
    return [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
}

function generateMaze(W, H) {
    const edges = new Set();
    const visited = new Set();
    const key = (x,y) => `${x},${y}`;
    const sx = Math.floor(Math.random() * W);
    const sy = Math.floor(Math.random() * H);
    visited.add(key(sx, sy));
    const frontier = [[sx, sy]];
    while (frontier.length > 0) {
        const idx = frontier.length - 1;
        const [cx, cy] = frontier[idx];
        const nbrs = neighbors4(cx, cy).filter(([nx,ny]) =>
            nx >= 0 && nx < W && ny >= 0 && ny < H && !visited.has(key(nx,ny))
        );
        if (nbrs.length > 0) {
            const [nx, ny] = nbrs[Math.floor(Math.random() * nbrs.length)];
            edges.add(edgeKey([cx,cy],[nx,ny]));
            visited.add(key(nx,ny));
            frontier.push([cx, cy]);
            frontier.push([nx, ny]);
        } else {
            // Occasional extra edge for loops (makes maze more interesting)
            if (Math.random() < 0.1) {
                const allNbrs = neighbors4(cx, cy).filter(([nx,ny]) =>
                    nx >= 0 && nx < W && ny >= 0 && ny < H);
                if (allNbrs.length > 0) {
                    const [nx, ny] = allNbrs[Math.floor(Math.random() * allNbrs.length)];
                    edges.add(edgeKey([cx,cy],[nx,ny]));
                }
            }
            frontier.splice(idx, 1);
        }
    }
    return { width: W, height: H, edges };
}

// ===== Compile + run solver =====
let compiledSolver = null;
let useBFS = true;

function compileSolver() {
    const src = editor.value;
    try {
        const t0 = performance.now();
        const jsCode = dx_compile_js(src);
        const dt = (performance.now() - t0).toFixed(1);
        compiledSolver = new Function('_W', '_H', '_USE_BFS', '_has_edge', jsCode + '\nreturn result;');
        appendMeta(`compiled in ${dt} ms`);
        return true;
    } catch (e) {
        appendErr('Compile error: ' + e.message);
        compiledSolver = null;
        return false;
    }
}

function runSolver(maze) {
    if (!compiledSolver) {
        if (!compileSolver()) return null;
    }
    const W = maze.width, H = maze.height;
    const edgeSet = maze.edges;
    function hasEdge(x1, y1, x2, y2) {
        return edgeSet.has(edgeKey([x1,y1],[x2,y2]));
    }
    // Capture console.log output
    const saved = console.log;
    const output = [];
    console.log = function(...args) {
        output.push(args.map(a =>
            a === true ? 'True' : a === false ? 'False' :
            a === null || a === undefined ? 'None' :
            Array.isArray(a) ? '[' + a.join(', ') + ']' : String(a)
        ).join(' '));
    };
    let result = null;
    try {
        const t0 = performance.now();
        result = compiledSolver(W, H, useBFS, hasEdge);
        const dt = (performance.now() - t0).toFixed(1);
        appendMeta(`solved in ${dt} ms`);
    } catch (e) {
        appendErr('Runtime error: ' + e.message);
    } finally {
        console.log = saved;
    }
    for (const line of output) appendOut(line);
    if (result) {
        return {
            explored: result.explored || [],
            path: result.path || [],
            goalReached: (result.gx >= 0) ? [result.gx, result.gy] : null
        };
    }
    return null;
}

// ===== Canvas rendering =====
const canvas = document.getElementById('maze');
const ctx = canvas.getContext('2d');
let maze, solution;

function resize() {
    const wrap = canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function drawMaze(maze, explored, exploredCount, path, pathCount) {
    const W = maze.width, H = maze.height;
    const cw = canvas.width / (window.devicePixelRatio || 1);
    const ch = canvas.height / (window.devicePixelRatio || 1);

    const pad = 24;
    const availW = cw - 2 * pad;
    const availH = ch - 2 * pad;
    const cellSize = Math.min(availW / W, availH / H);
    const mazeW = cellSize * W;
    const mazeH = cellSize * H;
    const offX = (cw - mazeW) / 2;
    const offY = (ch - mazeH) / 2;

    ctx.clearRect(0, 0, cw, ch);

    // Background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(offX, offY, mazeW, mazeH);

    // Explored cells (green)
    if (explored && exploredCount > 0) {
        const count = Math.min(exploredCount, explored.length);
        for (let i = 0; i < count; i++) {
            const [ex, ey] = explored[i];
            const alpha = 0.08 + 0.12 * (i / Math.max(count, 1));
            ctx.fillStyle = `rgba(45, 164, 78, ${alpha})`;
            ctx.fillRect(offX + ex * cellSize, offY + ey * cellSize, cellSize, cellSize);
        }
    }

    // Path cells (red tint)
    if (path && pathCount > 0) {
        const count = Math.min(pathCount, path.length);
        for (let i = 0; i < count; i++) {
            const [px, py] = path[i];
            ctx.fillStyle = 'rgba(207, 34, 46, 0.12)';
            ctx.fillRect(offX + px * cellSize, offY + py * cellSize, cellSize, cellSize);
        }
    }

    // Mark start and exits
    const start = [0, 0];
    const exits = [[W-1, H-1], [W-1, 0], [0, H-1]];

    ctx.fillStyle = 'rgba(5, 80, 174, 0.15)';
    ctx.fillRect(offX + start[0]*cellSize, offY + start[1]*cellSize, cellSize, cellSize);

    for (const [ex, ey] of exits) {
        ctx.fillStyle = 'rgba(207, 34, 46, 0.12)';
        ctx.fillRect(offX + ex * cellSize, offY + ey * cellSize, cellSize, cellSize);
    }

    // Walls
    ctx.strokeStyle = '#8b949e';
    ctx.lineWidth = Math.max(1.5, cellSize / 12);
    ctx.lineCap = 'round';

    const exitEdges = new Set();
    exitEdges.add(edgeKey([0,0],[0,-1]));
    exitEdges.add(edgeKey([W-1,H-1],[W-1,H]));
    exitEdges.add(edgeKey([W-1,0],[W,0]));
    exitEdges.add(edgeKey([0,H-1],[0,H]));
    const allEdges = new Set([...maze.edges, ...exitEdges]);

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            for (const [nx, ny] of neighbors4(x, y)) {
                if (!allEdges.has(edgeKey([x,y],[nx,ny]))) {
                    drawWall(ctx, x, y, nx, ny, offX, offY, cellSize);
                }
            }
        }
    }

    // Path line (red)
    if (path && pathCount > 1) {
        const count = Math.min(pathCount, path.length);
        ctx.strokeStyle = '#cf222e';
        ctx.lineWidth = Math.max(2, cellSize / 5);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < count; i++) {
            const sx = offX + path[i][0] * cellSize + cellSize / 2;
            const sy = offY + path[i][1] * cellSize + cellSize / 2;
            if (i === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
    }

    // Start marker
    {
        const sx = offX + start[0] * cellSize + cellSize / 2;
        const sy = offY + start[1] * cellSize + cellSize / 2;
        const r = Math.max(3, cellSize / 4);
        ctx.fillStyle = '#0550ae';
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(8, cellSize * 0.35)}px SF Mono, Consolas, monospace`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('S', sx, sy + 0.5);
    }

    // Exit markers
    for (const [ex, ey] of exits) {
        const sx = offX + ex * cellSize + cellSize / 2;
        const sy = offY + ey * cellSize + cellSize / 2;
        const r = Math.max(3, cellSize / 4);
        const isReached = solution && solution.goalReached &&
            solution.goalReached[0] === ex && solution.goalReached[1] === ey;
        ctx.fillStyle = isReached ? '#cf222e' : 'rgba(207,34,46,0.4)';
        ctx.beginPath(); ctx.arc(sx, sy, r, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(8, cellSize * 0.35)}px SF Mono, Consolas, monospace`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('E', sx, sy + 0.5);
    }
}

function drawWall(ctx, x1, y1, x2, y2, offX, offY, cs) {
    if (x1 === x2) {
        const wy = Math.max(y1, y2);
        ctx.beginPath();
        ctx.moveTo(offX + x1 * cs, offY + wy * cs);
        ctx.lineTo(offX + (x1 + 1) * cs, offY + wy * cs);
        ctx.stroke();
    } else {
        const wx = Math.max(x1, x2);
        ctx.beginPath();
        ctx.moveTo(offX + wx * cs, offY + y1 * cs);
        ctx.lineTo(offX + wx * cs, offY + (y1 + 1) * cs);
        ctx.stroke();
    }
}

// ===== Console helpers =====
function clearConsole() { consoleOut.innerHTML = ''; }
function appendOut(text) {
    consoleOut.appendChild(document.createTextNode(text + '\n'));
    consoleOut.scrollTop = consoleOut.scrollHeight;
}
function appendErr(text) {
    const span = document.createElement('span');
    span.className = 'err';
    span.textContent = text + '\n';
    consoleOut.appendChild(span);
}
function appendMeta(text) {
    const span = document.createElement('span');
    span.className = 'meta';
    span.textContent = '// ' + text + '\n';
    consoleOut.appendChild(span);
}

// ===== Animation stepper =====
let stepper = null;
let animating = false;
let animId = null;

function ensureSolution() {
    if (solution) return true;
    clearConsole();
    compiledSolver = null; // recompile on each solve
    const algoName = useBFS ? 'bfs' : 'dfs';
    document.getElementById('s-algo').textContent = algoName;
    appendMeta(`${algoName.toUpperCase()} (dx \u2192 JS, in-browser)`);

    solution = runSolver(maze);
    if (!solution || !solution.path.length) {
        appendOut('No path found.');
        return false;
    }

    stepper = {
        phase: 'explore',
        exploreCount: 0,
        pathCount: 0,
        totalExplored: solution.explored.length,
        totalPath: solution.path.length,
        algoName
    };
    return true;
}

function redrawStepper() {
    const st = stepper;
    if (st.phase === 'explore') {
        drawMaze(maze, solution.explored, st.exploreCount, null, 0);
        document.getElementById('s-explored').textContent = st.exploreCount;
        document.getElementById('s-path').textContent = '-';
    } else {
        drawMaze(maze, solution.explored, st.totalExplored, solution.path, st.pathCount);
        document.getElementById('s-explored').textContent = st.totalExplored + ' cells';
        document.getElementById('s-path').textContent = st.pathCount >= st.totalPath
            ? `${st.totalPath} steps` : `${st.pathCount}...`;
    }
}

function isFinished() {
    return stepper && stepper.phase === 'path' && stepper.pathCount >= stepper.totalPath;
}

function finishSolve() {
    document.getElementById('s-path').textContent = stepper.totalPath + ' steps';
    document.getElementById('s-explored').textContent = stepper.totalExplored + ' cells';
    const algoName = useBFS ? 'BFS' : 'DFS';
    appendOut(`${algoName}: path ${stepper.totalPath} steps, explored ${stepper.totalExplored} cells`);
}

function stopAnimation() {
    if (animId) clearTimeout(animId);
    animating = false;
    animId = null;
    document.getElementById('btnSolve').classList.remove('active');
    document.getElementById('btnSolve').textContent = 'solve';
}

function startSolve() {
    if (animating) {
        stopAnimation();
        if (solution && stepper) {
            stepper.exploreCount = stepper.totalExplored;
            stepper.phase = 'path';
            stepper.pathCount = stepper.totalPath;
            redrawStepper();
            finishSolve();
        }
        return;
    }

    if (!ensureSolution()) return;

    if (isFinished()) {
        solution = null; stepper = null;
        if (!ensureSolution()) return;
    }

    animating = true;
    document.getElementById('btnSolve').classList.add('active');
    document.getElementById('btnSolve').textContent = 'stop';

    const speedVal = parseInt(document.getElementById('speedSlider').value);
    const delay = Math.max(0, Math.round(100 - speedVal));
    const cellsPerTick = Math.max(1, Math.floor(speedVal / 20));

    function animate() {
        if (!animating) return;
        const st = stepper;

        if (st.phase === 'explore') {
            st.exploreCount = Math.min(st.exploreCount + cellsPerTick, st.totalExplored);
            if (st.exploreCount >= st.totalExplored) st.phase = 'path';
        } else {
            st.pathCount = Math.min(st.pathCount + cellsPerTick, st.totalPath);
            if (st.pathCount >= st.totalPath) {
                redrawStepper();
                finishSolve();
                stopAnimation();
                return;
            }
        }
        redrawStepper();
        animId = setTimeout(animate, delay);
    }
    animId = setTimeout(animate, delay);
}

function doStep() {
    if (animating) stopAnimation();
    if (!ensureSolution()) return;
    if (isFinished()) return;

    const st = stepper;
    if (st.phase === 'explore') {
        st.exploreCount = Math.min(st.exploreCount + 1, st.totalExplored);
        if (st.exploreCount >= st.totalExplored) {
            st.phase = 'path';
            st.pathCount = st.totalPath;
            redrawStepper();
            finishSolve();
            return;
        }
    } else {
        st.pathCount = Math.min(st.pathCount + 1, st.totalPath);
        if (st.pathCount >= st.totalPath) {
            redrawStepper();
            finishSolve();
            return;
        }
    }
    redrawStepper();
}

function newMaze() {
    stopAnimation();
    solution = null;
    stepper = null;
    compiledSolver = null;
    const size = parseInt(document.getElementById('sizeSlider').value);
    maze = generateMaze(size, size);
    document.getElementById('s-grid').textContent = `${size}x${size}`;
    document.getElementById('s-path').textContent = '-';
    document.getElementById('s-explored').textContent = '-';
    clearConsole();
    appendMeta(`Generated ${size}x${size} maze.`);
    resize();
    drawMaze(maze, null, 0, null, 0);
}

function setAlgo(bfs) {
    useBFS = bfs;
    document.getElementById('btnBfs').classList.toggle('active', bfs);
    document.getElementById('btnDfs').classList.toggle('active', !bfs);
    document.getElementById('s-algo').textContent = bfs ? 'bfs' : 'dfs';
    // Reset solution on algo change
    if (animating) stopAnimation();
    solution = null;
    stepper = null;
    if (maze) {
        document.getElementById('s-path').textContent = '-';
        document.getElementById('s-explored').textContent = '-';
        drawMaze(maze, null, 0, null, 0);
    }
}

// ===== Event listeners =====
document.getElementById('btnNew').addEventListener('click', newMaze);
document.getElementById('btnSolve').addEventListener('click', startSolve);
document.getElementById('btnStep').addEventListener('click', doStep);
document.getElementById('btnBfs').addEventListener('click', () => setAlgo(true));
document.getElementById('btnDfs').addEventListener('click', () => setAlgo(false));
document.getElementById('sizeSlider').addEventListener('input', newMaze);

window.addEventListener('resize', () => {
    resize();
    if (stepper && solution && !animating) {
        redrawStepper();
    } else if (maze) {
        drawMaze(maze, null, 0, null, 0);
    }
});

// Keyboard shortcuts (when editor not focused)
document.addEventListener('keydown', (e) => {
    if (document.activeElement === editor) return;
    if (e.key === 'n' || e.key === 'N') newMaze();
    if (e.key === ' ' || e.key === 's' || e.key === 'S') { e.preventDefault(); startSolve(); }
    if (e.key === '.' || e.key === 'ArrowRight') { e.preventDefault(); doStep(); }
    if (e.key === 'b' || e.key === 'B') setAlgo(true);
    if (e.key === 'd' || e.key === 'D') setAlgo(false);
});

// ===== Init =====
resize();
newMaze();
</script>

</body>
</html>
