<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dx — Significato geometrico del neurone</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
body {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    background: #0a0a0a; color: #e0e0e0;
    min-height: 100vh;
}

main {
    display: grid; grid-template-columns: 420px 1fr;
    height: 100vh;
}
@media (max-width: 900px) {
    main { grid-template-columns: 1fr; }
    .code-panel { max-height: 40vh; }
}

/* ── Code panel ── */
.code-panel {
    border-right: 1px solid #21262d; overflow: auto; padding: 0;
    background: #0d1117; display: flex; flex-direction: column;
}
.editor-wrap {
    position: relative; width: 100%; flex: 1;
    overflow: hidden;
}
.editor-wrap pre, .editor-wrap textarea {
    font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'Menlo', 'Consolas', monospace;
    font-size: 13px; line-height: 1.5; padding: 12px 16px;
    tab-size: 4; margin: 0; border: none; outline: none;
    white-space: pre; overflow: auto;
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
}
.editor-highlight {
    background: #0d1117; color: #c9d1d9; pointer-events: none; z-index: 0;
}
.editor-textarea {
    background: transparent; color: transparent; caret-color: #c9d1d9;
    z-index: 1; resize: none; -webkit-text-fill-color: transparent;
}
.kw { color: #ff7b72; }
.ty { color: #79c0ff; }
.fn { color: #d2a8ff; }
.num { color: #79c0ff; }
.str { color: #a5d6ff; }
.cm { color: #8b949e; font-style: italic; }
.pr { color: #ffa657; font-weight: 600; }
.op { color: #ff7b72; }

/* ── Viz panel ── */
.viz-panel {
    display: flex; flex-direction: column;
    background: #0a0a0a; overflow: auto;
}

.formula-bar {
    padding: 10px 16px;
    font-size: 13px;
    color: #8b949e;
    border-bottom: 1px solid #1a1a1a;
    min-height: 38px;
    display: flex; align-items: center; gap: 24px;
}
.formula-bar .eq { color: #c9d1d9; }
.formula-bar .hover-info { color: #f0c040; }

.canvas-wrap {
    flex: 1; display: flex; align-items: center; justify-content: center;
    padding: 16px; min-height: 0;
}
canvas#cv {
    background: #0d1117; border-radius: 6px;
    cursor: crosshair;
}

.controls-bar {
    padding: 12px 16px; border-top: 1px solid #1a1a1a;
    display: flex; flex-direction: column; gap: 10px;
}
.slider-row {
    display: flex; align-items: center; gap: 10px;
}
.slider-row label {
    font-size: 12px; color: #8b949e; min-width: 28px; text-align: right;
}
.slider-row input[type="range"] {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 4px;
    background: #333; border-radius: 2px; outline: none;
}
.slider-row input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 18px; height: 18px;
    background: #f0c040; border-radius: 50%; cursor: pointer;
}
.slider-row input[type="range"]::-moz-range-thumb {
    width: 18px; height: 18px;
    background: #f0c040; border-radius: 50%; cursor: pointer; border: none;
}
.slider-row .val {
    font-size: 12px; color: #c9d1d9; min-width: 42px;
    font-variant-numeric: tabular-nums;
}

.act-row {
    display: flex; align-items: center; gap: 8px;
}
.act-row span { font-size: 12px; color: #8b949e; }
.act-btn {
    background: #21262d; color: #c9d1d9; border: 1px solid #30363d;
    border-radius: 6px; padding: 4px 12px; font-size: 12px;
    font-family: inherit; cursor: pointer; transition: all 0.15s;
}
.act-btn:hover { border-color: #58a6ff; }
.act-btn.active { background: #1f3a5f; border-color: #58a6ff; color: #58a6ff; }
</style>
</head>
<body>

<main>
    <section class="code-panel">
        <div class="editor-wrap">
            <pre class="editor-highlight" id="editor-highlight"></pre>
            <textarea class="editor-textarea" id="source-editor" spellcheck="false"></textarea>
        </div>
    </section>

    <section class="viz-panel">
        <div class="formula-bar" id="formula-bar">
            <span class="eq" id="eq-text"></span>
            <span class="hover-info" id="hover-info"></span>
        </div>
        <div class="canvas-wrap">
            <canvas id="cv"></canvas>
        </div>
        <div class="controls-bar">
            <div class="slider-row">
                <label>w&#8321;</label>
                <input type="range" id="sl-w1" min="-3" max="3" step="0.05" value="1.0">
                <span class="val" id="val-w1">1.00</span>
            </div>
            <div class="slider-row">
                <label>w&#8322;</label>
                <input type="range" id="sl-w2" min="-3" max="3" step="0.05" value="0.5">
                <span class="val" id="val-w2">0.50</span>
            </div>
            <div class="slider-row">
                <label>b</label>
                <input type="range" id="sl-b" min="-5" max="5" step="0.05" value="-0.3">
                <span class="val" id="val-b">-0.30</span>
            </div>
            <div class="act-row">
                <span>Attivazione:</span>
                <button class="act-btn active" data-act="sigmoid">sigmoid</button>
                <button class="act-btn" data-act="relu">relu</button>
                <button class="act-btn" data-act="none">none</button>
            </div>
        </div>
    </section>
</main>

<script>
// ── State ──
let w1 = 1.0, w2 = 0.5, b = -0.3;
let activation = 'sigmoid';
const RANGE = 3; // viewport [-3, 3]

// ── DOM refs ──
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const ta = document.getElementById('source-editor');
const pre = document.getElementById('editor-highlight');
const eqText = document.getElementById('eq-text');
const hoverInfo = document.getElementById('hover-info');
const slW1 = document.getElementById('sl-w1');
const slW2 = document.getElementById('sl-w2');
const slB  = document.getElementById('sl-b');
const valW1 = document.getElementById('val-w1');
const valW2 = document.getElementById('val-w2');
const valB  = document.getElementById('val-b');

// ── DX source template ──
function makeDxSource() {
    const actFn = activation === 'none' ? '' : activation;
    const bodyExpr = actFn
        ? `${actFn}(me'w · x + me'b)`
        : `me'w · x + me'b`;
    return `type Neuron
    w : Tensor[1 2]
    b : Vec[1]

fun Neuron'apply(x: Vec[2]) -> Vec[1]
    ${bodyExpr}

-- weights
w1 = ${w1.toFixed(2)}
w2 = ${w2.toFixed(2)}
b  = ${b.toFixed(2)}`;
}

// ── Syntax highlighting ──
function highlightDx(code) {
    let h = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return h.split('\n').map(line => {
        const cmIdx = line.indexOf('--');
        let cp = cmIdx >= 0 ? line.slice(0, cmIdx) : line;
        let cm = cmIdx >= 0 ? '<span class="cm">' + line.slice(cmIdx) + '</span>' : '';
        cp = cp.replace(/("(?:[^"\\]|\\.)*?")/g, '<span class="str">$1</span>');
        cp = cp.replace(/\b(type|fun|for|if|in|print|arena|let|return)\b/g, '<span class="kw">$1</span>');
        cp = cp.replace(/\b(Neuron|Net|Vec|Tensor|Float|Int|String)\b/g, '<span class="ty">$1</span>');
        cp = cp.replace(/\b(it|me)\b/g, '<span class="pr">$1</span>');
        cp = cp.replace(/\b(nn|mse|sigmoid|relu|softmax|gelu)\b/g, '<span class="fn">$1</span>');
        cp = cp.replace(/ \. /g, ' \u00b7 ');
        cp = cp.replace(/\b(\d+\.?\d*)\b/g, '<span class="num">$1</span>');
        return cp + cm;
    }).join('\n');
}

function syncHighlight() {
    pre.innerHTML = highlightDx(ta.value) + '\n';
}
function syncScroll() {
    pre.scrollTop = ta.scrollTop;
    pre.scrollLeft = ta.scrollLeft;
}

// ── Parse code → extract w1, w2, b, activation ──
function parseCode() {
    const code = ta.value;
    const m1 = code.match(/w1\s*=\s*(-?\d+\.?\d*)/);
    const m2 = code.match(/w2\s*=\s*(-?\d+\.?\d*)/);
    const mb = code.match(/b\s*=\s*(-?\d+\.?\d*)/);
    if (m1) w1 = parseFloat(m1[1]);
    if (m2) w2 = parseFloat(m2[1]);
    if (mb) b  = parseFloat(mb[1]);
    // detect activation from body
    if (/sigmoid\s*\(/.test(code)) activation = 'sigmoid';
    else if (/relu\s*\(/.test(code)) activation = 'relu';
    else activation = 'none';
    // sync sliders
    slW1.value = w1; valW1.textContent = w1.toFixed(2);
    slW2.value = w2; valW2.textContent = w2.toFixed(2);
    slB.value  = b;  valB.textContent  = b.toFixed(2);
    // sync act buttons
    document.querySelectorAll('.act-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.act === activation);
    });
}

// ── Update code from state (slider / button change) ──
function updateCodeFromState() {
    let code = ta.value;
    code = code.replace(/(w1\s*=\s*)-?\d+\.?\d*/, `$1${w1.toFixed(2)}`);
    code = code.replace(/(w2\s*=\s*)-?\d+\.?\d*/, `$1${w2.toFixed(2)}`);
    code = code.replace(/(b\s*=\s*)-?\d+\.?\d*/,  `$1${b.toFixed(2)}`);
    // update activation in body
    const actFn = activation === 'none' ? '' : activation;
    const bodyExpr = actFn
        ? `${actFn}(me'w \u00b7 x + me'b)`
        : `me'w \u00b7 x + me'b`;
    code = code.replace(/^(    ).*w.*x.*b.*$/m, `$1${bodyExpr}`);
    ta.value = code;
    syncHighlight();
}

// ── Neuron math ──
function neuronRaw(x1, x2) { return w1 * x1 + w2 * x2 + b; }
function sigmoid(z) { return 1 / (1 + Math.exp(-z)); }
function relu(z) { return Math.max(0, z); }

function neuronOut(x1, x2) {
    const z = neuronRaw(x1, x2);
    if (activation === 'sigmoid') return sigmoid(z);
    if (activation === 'relu') return relu(z);
    return z;
}

// ── Canvas sizing ──
let W, H, dpr;
function resizeCanvas() {
    const wrap = cv.parentElement;
    const size = Math.min(wrap.clientWidth - 32, wrap.clientHeight - 32, 600);
    dpr = window.devicePixelRatio || 1;
    W = H = size;
    cv.style.width = size + 'px';
    cv.style.height = size + 'px';
    cv.width = size * dpr;
    cv.height = size * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// ── Coordinate transforms ──
function toScreen(wx, wy) {
    return [
        (wx - (-RANGE)) / (2 * RANGE) * W,
        W - (wy - (-RANGE)) / (2 * RANGE) * H
    ];
}
function toWorld(sx, sy) {
    return [
        (sx / W) * 2 * RANGE - RANGE,
        (1 - sy / H) * 2 * RANGE - RANGE
    ];
}

// ── Heatmap via offscreen canvas ──
const HEATMAP_RES = 100;
const heatCanvas = document.createElement('canvas');
heatCanvas.width = HEATMAP_RES;
heatCanvas.height = HEATMAP_RES;
const heatCtx = heatCanvas.getContext('2d');

function colorSigmoid(v) {
    // v in [0,1]: blue(0) → red(1)
    const r = Math.round(30 + 225 * v);
    const g = Math.round(60 + 40 * v - 80 * v * v);
    const bl = Math.round(200 - 170 * v);
    return `rgb(${r},${g},${bl})`;
}
function colorRelu(v, maxV) {
    // v in [0, maxV]: dark → yellow
    const t = maxV > 0 ? Math.min(v / maxV, 1) : 0;
    const r = Math.round(20 + 220 * t);
    const g = Math.round(20 + 180 * t);
    const bl = Math.round(20 + 20 * t);
    return `rgb(${r},${g},${bl})`;
}
function colorLinear(v, minV, maxV) {
    // v: blue(negative) → dark(0) → red(positive)
    const range = Math.max(Math.abs(minV), Math.abs(maxV), 0.01);
    const t = v / range; // -1..1
    if (t < 0) {
        const s = -t;
        return `rgb(${Math.round(20 + 20 * s)},${Math.round(40 + 40 * s)},${Math.round(60 + 160 * s)})`;
    } else {
        const s = t;
        return `rgb(${Math.round(60 + 180 * s)},${Math.round(40 - 10 * s)},${Math.round(40 - 20 * s)})`;
    }
}

function drawHeatmap() {
    const imgData = heatCtx.createImageData(HEATMAP_RES, HEATMAP_RES);
    const data = imgData.data;
    // pre-compute values
    const vals = new Float32Array(HEATMAP_RES * HEATMAP_RES);
    let minV = Infinity, maxV = -Infinity;
    for (let j = 0; j < HEATMAP_RES; j++) {
        for (let i = 0; i < HEATMAP_RES; i++) {
            const x1 = -RANGE + (i + 0.5) / HEATMAP_RES * 2 * RANGE;
            const x2 =  RANGE - (j + 0.5) / HEATMAP_RES * 2 * RANGE;
            const v = neuronOut(x1, x2);
            vals[j * HEATMAP_RES + i] = v;
            if (v < minV) minV = v;
            if (v > maxV) maxV = v;
        }
    }
    for (let j = 0; j < HEATMAP_RES; j++) {
        for (let i = 0; i < HEATMAP_RES; i++) {
            const idx = (j * HEATMAP_RES + i) * 4;
            const v = vals[j * HEATMAP_RES + i];
            let r, g, bl;
            if (activation === 'sigmoid') {
                r = Math.round(30 + 225 * v);
                g = Math.round(60 + 40 * v - 80 * v * v);
                bl = Math.round(200 - 170 * v);
            } else if (activation === 'relu') {
                const t = maxV > 0 ? Math.min(v / maxV, 1) : 0;
                r = Math.round(20 + 220 * t);
                g = Math.round(20 + 180 * t);
                bl = Math.round(20 + 20 * t);
            } else {
                const range = Math.max(Math.abs(minV), Math.abs(maxV), 0.01);
                const t = v / range;
                if (t < 0) {
                    const s = -t;
                    r = Math.round(20 + 20 * s);
                    g = Math.round(40 + 40 * s);
                    bl = Math.round(60 + 160 * s);
                } else {
                    const s = t;
                    r = Math.round(60 + 180 * s);
                    g = Math.round(40 - 10 * s);
                    bl = Math.round(40 - 20 * s);
                }
            }
            data[idx]     = r;
            data[idx + 1] = g;
            data[idx + 2] = bl;
            data[idx + 3] = 255;
        }
    }
    heatCtx.putImageData(imgData, 0, 0);
    // draw scaled with smoothing
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(heatCanvas, 0, 0, W, H);
}

// ── Grid + axes ──
function drawGrid() {
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    for (let g = -RANGE + 1; g < RANGE; g++) {
        const [sx] = toScreen(g, 0);
        ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
        const [, sy] = toScreen(0, g);
        ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
    }
    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1.5;
    const [ax] = toScreen(0, 0);
    const [, ay] = toScreen(0, 0);
    ctx.beginPath(); ctx.moveTo(0, ay); ctx.lineTo(W, ay); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ax, 0); ctx.lineTo(ax, H); ctx.stroke();
    // tick labels
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '11px SF Mono, Consolas, monospace';
    ctx.textAlign = 'center';
    for (let g = -RANGE + 1; g < RANGE; g++) {
        if (g === 0) continue;
        const [sx] = toScreen(g, 0);
        ctx.fillText(g, sx, ay + 14);
    }
    ctx.textAlign = 'right';
    for (let g = -RANGE + 1; g < RANGE; g++) {
        if (g === 0) continue;
        const [, sy] = toScreen(0, g);
        ctx.fillText(g, ax - 6, sy + 4);
    }
    // axis labels
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '12px SF Mono, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.fillText('x\u2081', W - 12, ay + 14);
    ctx.textAlign = 'right';
    ctx.fillText('x\u2082', ax - 6, 14);
}

// ── Decision boundary: w1*x1 + w2*x2 + b = 0 ──
function drawBoundary() {
    // Find intersections of line w1*x1 + w2*x2 + b = 0 with viewport
    const pts = [];
    const lo = -RANGE, hi = RANGE;
    if (Math.abs(w2) > 1e-9) {
        // x2 = (-w1*x1 - b) / w2
        const x2atLo = (-w1 * lo - b) / w2;
        const x2atHi = (-w1 * hi - b) / w2;
        if (x2atLo >= lo && x2atLo <= hi) pts.push([lo, x2atLo]);
        if (x2atHi >= lo && x2atHi <= hi) pts.push([hi, x2atHi]);
    }
    if (Math.abs(w1) > 1e-9) {
        // x1 = (-w2*x2 - b) / w1
        const x1atLo = (-w2 * lo - b) / w1;
        const x1atHi = (-w2 * hi - b) / w1;
        if (x1atLo > lo && x1atLo < hi) pts.push([x1atLo, lo]);
        if (x1atHi > lo && x1atHi < hi) pts.push([x1atHi, hi]);
    }
    if (pts.length < 2) return;
    // Draw white bold line
    const [sx0, sy0] = toScreen(pts[0][0], pts[0][1]);
    const [sx1, sy1] = toScreen(pts[1][0], pts[1][1]);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(sx1, sy1);
    ctx.stroke();
}

// ── Normal vector w ──
function drawNormal() {
    const wLen = Math.sqrt(w1 * w1 + w2 * w2);
    if (wLen < 1e-9) return;
    // Point on boundary closest to origin: p = -b * w / |w|^2
    const px = -b * w1 / (wLen * wLen);
    const py = -b * w2 / (wLen * wLen);
    // Arrow endpoint: p + normalized_w * scale
    const arrowLen = 0.8;
    const ex = px + (w1 / wLen) * arrowLen;
    const ey = py + (w2 / wLen) * arrowLen;
    const [sx0, sy0] = toScreen(px, py);
    const [sx1, sy1] = toScreen(ex, ey);
    // draw arrow line
    ctx.strokeStyle = '#f0c040';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(sx0, sy0);
    ctx.lineTo(sx1, sy1);
    ctx.stroke();
    // arrowhead
    const angle = Math.atan2(sy1 - sy0, sx1 - sx0);
    const headLen = 10;
    ctx.fillStyle = '#f0c040';
    ctx.beginPath();
    ctx.moveTo(sx1, sy1);
    ctx.lineTo(sx1 - headLen * Math.cos(angle - 0.4), sy1 - headLen * Math.sin(angle - 0.4));
    ctx.lineTo(sx1 - headLen * Math.cos(angle + 0.4), sy1 - headLen * Math.sin(angle + 0.4));
    ctx.closePath();
    ctx.fill();
    // label "w"
    const lx = sx1 + 12 * Math.cos(angle);
    const ly = sy1 + 12 * Math.sin(angle);
    ctx.fillStyle = '#f0c040';
    ctx.font = 'bold 14px SF Mono, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.fillText('w', lx, ly + 4);
}

// ── Region labels ──
function drawLabels() {
    const wLen = Math.sqrt(w1 * w1 + w2 * w2);
    if (wLen < 1e-9) return;
    const nx = w1 / wLen, ny = w2 / wLen;
    // point on boundary closest to origin
    const px = -b * w1 / (wLen * wLen);
    const py = -b * w2 / (wLen * wLen);
    // offset from boundary along normal
    const off = 0.9;
    const posX = px + nx * off, posY = py + ny * off;
    const negX = px - nx * off, negY = py - ny * off;
    // Clamp to viewport
    function clamp(v) { return Math.max(-RANGE + 0.5, Math.min(RANGE - 0.5, v)); }
    const [spx, spy] = toScreen(clamp(posX), clamp(posY));
    const [snx, sny] = toScreen(clamp(negX), clamp(negY));
    ctx.font = '12px SF Mono, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.65)';
    ctx.fillText('w\u00b7x + b > 0', spx, spy);
    ctx.fillText('w\u00b7x + b < 0', snx, sny);
}

// ── Main draw ──
function draw() {
    ctx.clearRect(0, 0, W, H);
    drawHeatmap();
    drawGrid();
    drawBoundary();
    drawNormal();
    drawLabels();
    updateFormula();
}

function updateFormula() {
    const s = (v) => v >= 0 ? `+${v.toFixed(2)}` : v.toFixed(2);
    eqText.textContent = `${w1.toFixed(2)}\u00b7x\u2081 ${s(w2)}\u00b7x\u2082 ${s(b)} = 0`;
}

// ── Hover ──
cv.addEventListener('mousemove', (e) => {
    const rect = cv.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const [x1, x2] = toWorld(sx, sy);
    if (x1 < -RANGE || x1 > RANGE || x2 < -RANGE || x2 > RANGE) {
        hoverInfo.textContent = '';
        return;
    }
    const out = neuronOut(x1, x2);
    hoverInfo.textContent = `(${x1.toFixed(2)}, ${x2.toFixed(2)})  \u2192  ${out.toFixed(4)}`;
});
cv.addEventListener('mouseleave', () => { hoverInfo.textContent = ''; });

// ── Slider events ──
function onSlider() {
    w1 = parseFloat(slW1.value);
    w2 = parseFloat(slW2.value);
    b  = parseFloat(slB.value);
    valW1.textContent = w1.toFixed(2);
    valW2.textContent = w2.toFixed(2);
    valB.textContent  = b.toFixed(2);
    updateCodeFromState();
    draw();
}
slW1.addEventListener('input', onSlider);
slW2.addEventListener('input', onSlider);
slB.addEventListener('input', onSlider);

// ── Activation buttons ──
document.querySelectorAll('.act-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        activation = btn.dataset.act;
        document.querySelectorAll('.act-btn').forEach(b => b.classList.toggle('active', b === btn));
        updateCodeFromState();
        draw();
    });
});

// ── Code editing → parse ──
ta.addEventListener('input', () => {
    syncHighlight();
    parseCode();
    draw();
});
ta.addEventListener('scroll', syncScroll);

// ── Init ──
function init() {
    ta.value = makeDxSource();
    syncHighlight();
    resizeCanvas();
    draw();
}

window.addEventListener('resize', () => { resizeCanvas(); draw(); });
init();
</script>
</body>
</html>
